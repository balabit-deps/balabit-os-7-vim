Backported of:

From cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8 Mon Sep 17 00:00:00 2001
From: Bram Moolenaar <Bram@vim.org>
Date: Mon, 24 Dec 2018 21:38:45 +0100
Subject: [PATCH] patch 8.1.0633: crash when out of memory while opening a
 terminal window

Problem:    Crash when out of memory while opening a terminal window.
Solution:   Handle out-of-memory more gracefully.
diff --git a/src/libvterm/src/state.c b/src/libvterm/src/state.c
index 5a6feac..27d6c51 100644
--- a/src/libvterm/src/state.c
+++ b/src/libvterm/src/state.c
@@ -53,6 +53,8 @@ static VTermState *vterm_state_new(VTerm *vt)
 {
   VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));
 
+  if (state == NULL)
+    return NULL;
   state->vt = vt;
 
   state->rows = vt->rows;
@@ -1668,6 +1670,10 @@ static const VTermParserCallbacks parser_callbacks = {
   on_resize /* resize */
 };
 
+/*
+ * Return the existing state or create a new one.
+ * Returns NULL when out of memory.
+ */
 VTermState *vterm_obtain_state(VTerm *vt)
 {
   VTermState *state;
@@ -1675,6 +1681,8 @@ VTermState *vterm_obtain_state(VTerm *vt)
     return vt->state;
 
   state = vterm_state_new(vt);
+  if (state == NULL)
+    return NULL;
   vt->state = state;
 
   state->combine_chars_size = 16;
diff --git a/src/libvterm/src/vterm.c b/src/libvterm/src/vterm.c
index 1789fb3..dc0a09b 100644
--- a/src/libvterm/src/vterm.c
+++ b/src/libvterm/src/vterm.c
@@ -1,5 +1,6 @@
 #define DEFINE_INLINES
 
+/* vim: set sw=2 : */
 #include "vterm_internal.h"
 
 #include <stdio.h>
@@ -41,6 +42,8 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun
   /* Need to bootstrap using the allocator function directly */
   VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);
 
+  if (vt == NULL)
+    return NULL;
   vt->allocator = funcs;
   vt->allocdata = allocdata;
 
@@ -55,10 +58,21 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun
   vt->strbuffer_len = 64;
   vt->strbuffer_cur = 0;
   vt->strbuffer = vterm_allocator_malloc(vt, vt->strbuffer_len);
+  if (vt->strbuffer == NULL)
+  {
+    vterm_allocator_free(vt, vt);
+    return NULL;
+  }
 
   vt->outbuffer_len = 64;
   vt->outbuffer_cur = 0;
   vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);
+  if (vt->outbuffer == NULL)
+  {
+    vterm_allocator_free(vt, vt->strbuffer);
+    vterm_allocator_free(vt, vt);
+    return NULL;
+  }
 
   return vt;
 }
@@ -82,9 +96,13 @@ INTERNAL void *vterm_allocator_malloc(VTerm *vt, size_t size)
   return (*vt->allocator->malloc)(size, vt->allocdata);
 }
 
+/*
+ * Free "ptr" unless it is NULL.
+ */
 INTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)
 {
-  (*vt->allocator->free)(ptr, vt->allocdata);
+  if (ptr)
+    (*vt->allocator->free)(ptr, vt->allocdata);
 }
 
 void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp)
diff --git a/src/terminal.c b/src/terminal.c
index 4c0c3de..f9f509c 100644
--- a/src/terminal.c
+++ b/src/terminal.c
@@ -2497,12 +2497,14 @@ cterm_color2rgb(int nr, VTermColor *rgb)
 
 /*
  * Create a new vterm and initialize it.
+ * Return FAIL when out of memory.
  */
-    static void
+    static int
 create_vterm(term_T *term, int rows, int cols)
 {
     VTerm	    *vterm;
     VTermScreen	    *screen;
+    VTermState	    *state;
     VTermValue	    value;
     VTermColor	    *fg, *bg;
     int		    fgval, bgval;
@@ -2510,7 +2512,18 @@ create_vterm(term_T *term, int rows, int cols)
 
     vterm = vterm_new(rows, cols);
     term->tl_vterm = vterm;
+    if (vterm == NULL)
+	return FAIL;
+
+    // Allocate screen and state here, so we can bail out if that fails.
+    state = vterm_obtain_state(vterm);
     screen = vterm_obtain_screen(vterm);
+    if (state == NULL || screen == NULL)
+    {
+	vterm_free(vterm);
+	return FAIL;
+    }
+
     vterm_screen_set_callbacks(screen, &screen_callbacks, term);
     /* TODO: depends on 'encoding'. */
     vterm_set_utf8(vterm, 1);
@@ -2638,7 +2651,7 @@ create_vterm(term_T *term, int rows, int cols)
 # endif
     }
 
-    vterm_state_set_default_colors(vterm_obtain_state(vterm), fg, bg);
+    vterm_state_set_default_colors(state, fg, bg);
 
     /* Required to initialize most things. */
     vterm_screen_reset(screen, 1 /* hard */);
@@ -2659,6 +2672,7 @@ create_vterm(term_T *term, int rows, int cols)
 #endif
     vterm_state_set_termprop(vterm_obtain_state(vterm),
 					       VTERM_PROP_CURSORBLINK, &value);
+    return OK;
 }
 
 /*
@@ -3513,7 +3527,8 @@ term_and_job_init(
     vim_free(cwd_wchar);
     vim_free(env_wchar);
 
-    create_vterm(term, term->tl_rows, term->tl_cols);
+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)
+	goto failed;
 
     channel_set_job(channel, job, opt);
     job_set_options(job, opt);
@@ -3574,7 +3589,8 @@ create_pty_only(term_T *term, jobopt_T *options)
     char	    in_name[80], out_name[80];
     channel_T	    *channel = NULL;
 
-    create_vterm(term, term->tl_rows, term->tl_cols);
+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)
+	return FAIL;
 
     vim_snprintf(in_name, sizeof(in_name), "\\\\.\\pipe\\vim-%d-in-%d",
 	    GetCurrentProcessId(),
@@ -3683,7 +3699,8 @@ term_and_job_init(
 	typval_T    *argvar,
 	jobopt_T    *opt)
 {
-    create_vterm(term, term->tl_rows, term->tl_cols);
+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)
+	return FAIL;
 
     term->tl_job = job_start(argvar, opt);
     if (term->tl_job != NULL)
@@ -3697,7 +3714,8 @@ term_and_job_init(
     static int
 create_pty_only(term_T *term, jobopt_T *opt)
 {
-    create_vterm(term, term->tl_rows, term->tl_cols);
+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)
+	return FAIL;
 
     term->tl_job = job_alloc();
     if (term->tl_job == NULL)
